# Форматированные строковые литералы

#В следующем примере число Пи округляется до трех знаков после запятой:

import math
print(f'The value of pi is approximately {math.pi:.3f}.')

# Передача целого числа после ':'приведет к тому, что это поле будет иметь
# минимальное количество символов. Это полезно для выравнивания столбцов.

table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
for name, phone in table.items():
    print(f'{name:10} ==> {phone:10d}')

# Спецификатор =можно использовать для расширения выражения до текста выражения, знака равенства, а затем представления вычисленного выражения:


bugs = 'roaches'
count = 13
area = 'living room'
print(f'Debugging {bugs=} {count=} {area=}')

#  Метод String format()

print('We are the {} who say "{}!"'.format('knights', 'Ni'))

print('This {food} is {adjective}.'.format(
      food='spam', adjective='absolutely horrible'))


print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
                                                   other='Georg'))

# Чтение и запись файлов

# open()возвращает файловый объект и чаще всего используется с
# двумя позиционными аргументами и одним аргументом ключевого слова:
# open(filename, mode, encoding=None)


f = open('../workfile', 'w', encoding="utf-8")
#Первый аргумент — это строка, содержащая имя файла. Второй аргумент — это еще одна строка,
# содержащая несколько символов, описывающих способ использования файла.
# режим может быть 'r'когда файл будет только для чтения, 'w' только для записи
# (существующий файл с таким же именем будет стерт), и 'a'открывает файл для добавления;
# любые данные, записанные в файл, автоматически добавляются в конец.
# 'r+'открывает файл как для чтения, так и для записи. Аргумент режима не является обязательным;
# 'r'будет принято, если оно опущено.

#Обычно файлы открываются в текстовом режиме , то есть вы читаете и записываете
# в файл строки, закодированные в определенной кодировке . Если кодировка не указана,
# значение по умолчанию зависит от платформы (см. Ресурсы open()). Поскольку
# UTF-8 является современным стандартом де-факто, encoding="utf-8"рекомендуется использовать его,
# если вы не знаете, что вам нужно использовать другую кодировку. Добавление 'b'к режиму открывает
# файл в двоичном режиме . Данные в двоичном режиме читаются и записываются как bytes объекты.
# Вы не можете указать кодировку при открытии файла в двоичном режиме.

#В текстовом режиме по умолчанию при чтении конвертируются окончания строк,
# специфичные для платформы ( \nв Unix, \r\nв Windows), в просто \n. При
# записи в текстовом режиме по умолчанию вхождения строк преобразуются
# \n обратно в окончания строк, специфичные для платформы.
# Эта закулисная модификация данных файла подходит для текстовых файлов,
# но приведет к повреждению двоичных данных, подобных этим,
# в файлах JPEGили EXE. Будьте очень осторожны при использовании двоичного режима
# при чтении и записи таких файлов.

#Рекомендуется использовать это withключевое слово при работе с файловыми объектами.
# Преимущество состоит в том, что файл корректно закрывается после завершения работы
# его пакета, даже если в какой-то момент возникает исключение. Использование withтакже намного короче,
# чем написание эквивалентных tryблоков finally:


with open('../workfile', encoding="utf-8") as f:
    read_data = f.read()

# We can check that the file has been automatically closed.
#f.closed

#Если вы не используете withключевое слово, вам следует позвонить f.close(),
# чтобы закрыть файл и немедленно освободить все используемые им системные ресурсы.

#Предупреждение Вызов f.write()без использования withключевого слова или вызов f.close()
# может привести к тому, что аргументы f.write()не будут полностью записаны на диск,
# даже если программа завершится успешно.
#После закрытия файлового объекта с помощью withинструкции или вызова f.close()попытки использовать
# файловый объект автоматически завершатся неудачей.


#f.close()
#f.read()

class B(Exception):
    pass

class C(B):
    pass

class D(C):
    pass

for cls in [B, C, D]:
    try:
        raise cls()
    except D:
        print("D")
    except C:
        print("C")
